---
title: "【Go1.24】testing/synctestパッケージを使ってみたいんじゃ〜"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# 導入

Go1.24 が 2025 年 2 月にリリースされました 🎉🎉🎉

型エイリアスがジェネリクスに対応したり、map の実装が Swiss Table になったりと細かな改善が行われました！

今回はこの中から、実験的に導入された [testing/synctest](https://pkg.go.dev/testing/synctest) パッケージについて紹介したいと思います！

この記事では、testing/synctest で実装された 2 つの API を紹介しつつ、**GoDoc に記載されている具体的な仕様**についても触れたいと思っています。

# 実装された背景

そもそもなぜ、testing/synctest パッケージが導入されたのでしょうか？

**「並列なプログラムのテストを行うことは時間がかかり、flakly なテストになりがち」** という課題を解決するために実装された、というのが回答になります！

flaky なテストとは、実行時にランダムで落ちてしまうテストのことです。
この後の章で、実際に時間がかかるテストを書いてみたり、flaky なテストを再現してみようと思っています。

そして、実際に testing/synctest を導入することで、上記の課題が解決することも確かめてみたいと思います 🙌

# 実際に試してみる！

今回のコードで使用する Go のバージョンは 1.24.0 になります。

```bash
❯ go version
go version go1.24.0 darwin/arm64
```

また VSCode で実際に試してみたい方は、下記の設定を `setting.json` に追加してみてください 🙆‍♂️

```json
{
  "go.toolsEnvVars": {
    "GOEXPERIMENT": "synctest"
  }
}
```

## 実験 1: 簡単なキャッシュ

まずは下記のような簡単なキャッシュの例で考えてみます。

```go
package main

import (
	"time"
)

func NewCache[T any]() *Cache[T] {
	return &Cache[T]{}
}

type Cache[T any] struct {
	v       T
	ttl     time.Duration
	setTime time.Time
}

func (c *Cache[T]) Set(value T, ttl time.Duration) {
	c.v = value
	c.ttl = ttl
	c.setTime = time.Now()
}

func (c *Cache[T]) Get() T {
	if time.Since(c.setTime) >= c.ttl {
		var zero T
		return zero
	}
	return c.v
}
```

`Set` にキャッシュしたい値と TTL を渡します。`Get`は自身が呼ばれた時、TTL で指定した時間が経過していた場合はゼロ値を返し、経過する前の場合はキャッシュした値を返します。

あえて時間をかかるテストを書きたいので、TTL を 5 秒とし、テストを以下のように書いてみます。

```go
package main

import (
	"testing"
	"time"
)

func TestCache_Get(t *testing.T) {
	ttl := 5 * time.Second
	cache := NewCache[string]()
	cache.Set("cached item", ttl)

	if got := cache.Get(); got != "cached item" {
		t.Errorf("expected 'cached item'; got %v", got)
	}

	time.Sleep(ttl)

	if got := cache.Get(); got != "" {
		t.Errorf("expected ''; got %v", got)
	}
}
```

実行してみます！

```bash
❯ GOEXPERIMENT=synctest go test -run "TestCache_Get"
PASS
ok      github.com/k3forx/go124 5.229s
```

当たり前ですが、5 秒以上かかるテストになっています 😢

### `Run` 関数を使ってテスト時間を短くする

ここで登場するのが testing/synctest パッケージの `Run` 関数です！

**`Run` 関数で先ほどのテストコードを Wrap する**だけです。

```go
func TestCache_Get(t *testing.T) {
	synctest.Run(func() {
		ttl := 5 * time.Second
		cache := NewCache[string]()
		cache.Set("cached item", ttl)

		if got := cache.Get(); got != "cached item" {
			t.Errorf("expected 'cached item'; got %v", got)
		}

		time.Sleep(ttl)

		if got := cache.Get(); got != "" {
			t.Errorf("expected ''; got %v", got)
		}
	})
}
```

実行してみます！

```bash
❯ GOEXPERIMENT=synctest go test -run "TestCache_Get"
PASS
ok      github.com/k3forx/go124 0.245s
```

実行時間が `5.229s` から `0.245s` に減りました！ 🎉🎉🎉

### `Run` 関数の GoDoc を見てみる！

さて、`Run` 関数はどのような挙動になっているのでしょうか？
（どういうロジックによって、テストの時間が短縮されるのでしょうか？）

GoDoc を見てみましょう 👀

```bash
❯ GOEXPERIMENT=synctest go doc testing/synctest.Run
package synctest // import "testing/synctest"

func Run(f func())
    Run executes f in a new goroutine.

    The new goroutine and any goroutines transitively started by it form an
    isolated "bubble". Run waits for all goroutines in the bubble to exit before
    returning.

    Goroutines in the bubble use a synthetic time implementation. The initial
    time is midnight UTC 2000-01-01.

    Time advances when every goroutine in the bubble is blocked. For example,
    a call to time.Sleep will block until all other goroutines are blocked and
    return after the bubble's clock has advanced. See Wait for the specific
    definition of blocked.

    If every goroutine is blocked and there are no timers scheduled, Run panics.

    Channels, time.Timers, and time.Tickers created within the bubble are
    associated with it. Operating on a bubbled channel, timer, or ticker from
    outside the bubble panics.
```

筆者が翻訳したものは以下になります。

## 実験 2: 簡単なキャッシュ v2

## おさらい（Go クイズ！）

# まとめ
