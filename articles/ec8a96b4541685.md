---
title: "【Go1.24】testing/synctestパッケージを使ってみたいんじゃ〜"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# 導入

Go1.24 が 2025 年 2 月にリリースされました 🎉🎉🎉

型エイリアスがジェネリクスに対応したり、map の実装が Swiss Table になったりと細かな改善が行われました！

今回はこの中から、実験的に導入された [testing/synctest](https://pkg.go.dev/testing/synctest) パッケージについて紹介したいと思います！

この記事では、testing/synctest で実装された 2 つの API を紹介しつつ、GoDoc に記載されている具体的な仕様についても触れたいと思っています。

# 実装された背景

そもそもなぜ、testing/synctest パッケージが導入されたのでしょうか？

**「並列なプログラムのテストを行うことは時間がかかり、flakly なテストになりがち」** という課題を解決するために実装された、というのが回答になります！

flaky なテストとは、実行時にランダムで落ちてしまうテストのことです。
この後の章で、実際に時間がかかるテストを書いてみたり、flaky なテストを再現してみようと思っています。

そして、実際に testing/synctest を導入することで、上記の課題が解決することも確かめてみたいと思います！

# 実際に試してみる！

今回のコードで使用する Go のバージョンは 1.24.0 になります。

```bash
❯ go version
go version go1.24.0 darwin/arm64
```

また VSCode で実際に試してみたい方は、下記の設定を `setting.json` に追加してみてください 🙆‍♂️

```json
{
  "go.toolsEnvVars": {
    "GOEXPERIMENT": "synctest"
  }
}
```

## 実験 1: 簡単なキャッシュ

まずは下記のような簡単なキャッシュの例で考えてみます。

```go
package main

import (
	"time"
)

func NewCache[T any]() *Cache[T] {
	return &Cache[T]{}
}

type Cache[T any] struct {
	v       T
	ttl     time.Duration
	setTime time.Time
}

func (c *Cache[T]) Set(value T, ttl time.Duration) {
	c.v = value
	c.ttl = ttl
	c.setTime = time.Now()
}

func (c *Cache[T]) Get() T {
	if time.Since(c.setTime) >= c.ttl {
		var zero T
		return zero
	}
	return c.v
}
```

`Set` にキャッシュしたい値と TTL を渡します。`Get`は自身が呼ばれた時、TTL で指定した時間が経過していた場合はゼロ値を返し、経過する前の場合はキャッシュした値を返します。

あえて時間をかかるテストを書きたいので、TTL を 5 秒とし、テストを以下のように書いてみます。

```go
package main

import (
	"testing"
	"time"
)

func TestCache_Get(t *testing.T) {
	ttl := 5 * time.Second
	cache := NewCache[string]()
	cache.Set("cached item", ttl)

	if got := cache.Get(); got != "cached item" {
		t.Errorf("Get() = %v; want 'cached item'", got)
	}

	time.Sleep(ttl)

	if got := cache.Get(); got != "" {
		t.Errorf("Get() = %v; want ''", got)
	}
}
```

## 実験 2: 簡単なキャッシュ v2

## おさらい（Go クイズ！）

# まとめ
