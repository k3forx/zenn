---
title: "ã€Go1.24ã€‘ã‚„ã£ã±ã‚Š `b.Loop` ã‚ˆã‚Š `b.N` ã§ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’æ›¸ã„ãŸæ–¹ãŒè‰¯ã„ï¼ï¼Ÿ"
emoji: "ğŸª‘"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Go", "test"]
published: false
---

# ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆã®æ”¹å–„ãŒã‚ã£ãŸï¼

[More predictable benchmarking with testing.B.Loop](https://go.dev/blog/testing-b-loop)

Go1.24 ã§ã¯ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆã®ã‚„ã‚Šæ–¹ãŒæ”¹å–„ã•ã‚Œã¾ã—ãŸ ğŸ™Œ

å…·ä½“çš„ãªæ›¸ãæ–¹ã®é•ã„ã‚’è¦‹ã¦ã¿ã¾ã™ã€‚ä¸‹è¨˜ã®ã‚ˆã†ãªãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆã¯

```go
func BenchmarkSomeFunc(b *testing.B) {
	for range b.N {
		// SomeFuncã‚’å‘¼ã¶å‡¦ç†
	}
}
```

`b.Loop` ã‚’ä½¿ã†ã“ã¨ã§ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚

```go
func BenchmarkSomeFunc(b *testing.B) {
	for b.Loop() {
		// SomeFuncã‚’å‘¼ã¶å‡¦ç†
	}
}
```

ã±ã£ã¨è¦‹ã ã¨ã‚ã‚“ã¾ã‚Šå¤‰ã‚ã‚‰ãªã•ãã†ã§ã™ã­ ğŸ‘€

# `b.Loop` ã®ä½•ãŒè‰¯ã„ã®ã‹ï¼Ÿ

[Go 1.24 Release Notes#new-benchmark-function](https://go.dev/doc/go1.24#new-benchmark-function) ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªè¨˜è¼‰ãŒè¦‹ã‚‰ã‚Œã¾ã™ï¼

> ãƒ»The benchmark function will execute exactly once per -count, so expensive setup and cleanup steps execute only once.  
> ãƒ»Function call parameters and results are kept alive, preventing the compiler from fully optimizing away the loop body.

**ã€Œå®Ÿè¡Œã‚³ã‚¹ãƒˆãŒã‹ã‹ã‚‹ãƒ†ã‚¹ãƒˆå‰å¾Œã® setup ã‚„ cleanup ã®é–¢æ•°ãŒå³å¯†ã« 1 å›ã—ã‹å‘¼ã°ã‚Œãªã„ã“ã¨ã€** ãŒ 1 ã¤ç›®ã®ãƒ¡ãƒªãƒƒãƒˆã¨ã—ã¦æŒ™ã’ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

ã›ã£ã‹ããªã®ã§è©¦ã—ã¦ã¿ã¾ã™ã€‚

- `main.go`

  ```go
  package main

  func Double(a int) int {
  	return a * 2
  }
  ```

- `main_test.go`

  ```go
  package main

  import (
  	"fmt"
  	"testing"
  )

  func Benchmark_Double_NormalLoop(b *testing.B) {
  	fmt.Println("before")
  	for range b.N {
  		Double(1)
  	}
  	fmt.Println("after")
  }

  func Benchmark_Double_NewLoop(b *testing.B) {
  	fmt.Println("before")
  	for b.Loop() {
  		Double(1)
  	}
  	fmt.Println("after")
  }
  ```

å®Ÿè¡Œã—ã¦ã¿ã¾ã™ï¼

```bash
â¯ go test -bench "Benchmark_Double_NormalLoop" -count=1
before
after
goos: darwin
goarch: arm64
pkg: github.com/k3forx/go124
cpu: Apple M3 Pro
Benchmark_Double_NormalLoop-11          before
after
before
after
before
after
before
after
before
after
1000000000               0.2536 ns/op
PASS
ok      github.com/k3forx/go124 0.469s
```

ç¢ºã‹ã« `b.N` ã‚’ä½¿ã£ãŸãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã§ã¯ `fmt.Println("before")` ã‚„ `fmt.Println("after")` ãŒè¤‡æ•°å›å®Ÿè¡Œã•ã‚Œã¦ã„ãã†ã§ã™ï¼

ä¸€æ–¹ã§ã€`b.Loop` ã®æ–¹ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ

```bash
â¯ go test -bench "Benchmark_Double_NewLoop" -count=1
before
after
goos: darwin
goarch: arm64
pkg: github.com/k3forx/go124
cpu: Apple M3 Pro
Benchmark_Double_NewLoop-11     992395766                1.018 ns/op
PASS
ok      github.com/k3forx/go124 1.180s
```

`fmt.Println("before")` ã¨ `fmt.Println("after")` ãŒãã‚Œãã‚Œ 1 å›ãšã¤ã—ã‹å‘¼ã°ã‚Œã¦ã„ã¾ã›ã‚“ ğŸ‰

---

**ã€Œãƒ«ãƒ¼ãƒ—ã®ä¸­èº«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒæœ€é©åŒ–ã—ã¦ã—ã¾ã†ã®ã‚’é˜²ãã“ã¨ã€** ãŒ 2 ã¤ç›®ã®ãƒ¡ãƒªãƒƒãƒˆã¨ã—ã¦æŒ™ã’ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã¡ã‚‰ã‚‚å…ˆã»ã©ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã¿ã¾ã™ã€‚`main_test.go` ã®å†…å®¹ã‚’ `main.go` ã«è¿½è¨˜ã—ã¦ä»¥ä¸‹ã®ã‚ˆã†ãª `main.go` ã‚’ä½œæˆã—ã¦ã¿ã¾ã™ã€‚

```bash
â¯ cat -n ./main.go
     1  package main
     2
     3  import "testing"
     4
     5  func main() {}
     6
     7  func Double(a int) int {
     8          return a * 2
     9  }
    10
    11  func Benchmark_Double_NormalLoop(b *testing.B) {
    12          for range b.N {
    13                  Double(1)
    14          }
    15  }
    16
    17  func Benchmark_Double_NewLoop(b *testing.B) {
    18          for b.Loop() {
    19                  Double(1)
    20          }
    21  }
```

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æœ€é©åŒ–ã®ãƒ•ãƒ©ã‚°ã‚’æœ‰åŠ¹ã«ã—ã¦ãƒ“ãƒ«ãƒ‰ã—ã¦ã¿ã¾ã™ï¼

```bash
â¯ go build -gcflags=-m .
# github.com/k3forx/go124
./main.go:5:6: can inline main
./main.go:7:6: can inline Double
./main.go:11:6: can inline Benchmark_Double_NormalLoop
./main.go:18:2: skip inlining within testing.B.loop for for loop
./main.go:13:9: inlining call to Double
./main.go:18:12: inlining call to testing.(*B).Loop
./main.go:11:34: b does not escape
./main.go:17:31: leaking param: b
```

`./main.go:13:9: inlining call to Double` ã¨ã‚ã‚‹ã‚ˆã†ã« `b.N` ã®ä¸­ã§å‘¼ã°ã‚Œã¦ã„ã‚‹ `Double` é–¢æ•°ã¯ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å±•é–‹ã•ã‚Œã„ãã†ã§ã™ï¼

ã¤ã¾ã‚Šã€**é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œãšã«ã€é©åˆ‡ãªãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆãŒå®Ÿè¡Œã•ã‚Œãªã„å¯èƒ½æ€§ãŒã‚ã‚‹** ã¨ã„ã†ã“ã¨ã§ã™ ğŸ˜±

# ä»–ã«ã‚‚ `b.N` ã‚’ä½¿ã£ãŸãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆã§æ°—ã‚’ã¤ã‘ãªã„ã¨ã„ã‘ãªã„ã¨ã“ã‚ãŒã‚ã‚‹...

ä¸Šè¨˜ã§æŒ™ã’ãŸ 2 ç‚¹ã®ä»–ã«ã‚‚ã€[More predictable benchmarking with testing.B.Loop](https://go.dev/blog/testing-b-loop) ã«ã¯ `b.N` ã®ä½¿ç”¨ä¸Šã®æ³¨æ„ç‚¹ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãã‚Œã¯ **`b.ResetTimer()` ã¨ `b.StopTimer()`** ã‚’å®Ÿè£…è€…ãŒæ›¸ã‹ãªã‘ã‚Œã°ã„ã‘ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚

ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ãªä¾‹ã§è€ƒãˆã¦ã¿ã¾ã™ã€‚

```go
func BenchmarkSomeFunc(b *testing.B) {
	// setupã®å‡¦ç†
	b.ResetTimer()
	for range b.N {
		// SomeFuncã‚’å‘¼ã¶å‡¦ç†
	}
	b.StopTimer()
	// cleanupã®å‡¦ç†
}
```

é©åˆ‡ãªãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆã®çµæœã‚’å¾—ã‚‹ãŸã‚ã« `b.ResetTimer()` ã¨ `b.StopTimer()` ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã®å®Ÿè£…ã‚’å¿˜ã‚Œã‚„ã™ã„ã¨ã„ã†ã“ã¨ãŒèª²é¡Œã¨ã—ã¦æŒ™ã’ã‚‰ã‚Œã¦ã„ã¾ã—ãŸã€‚

---

ã—ã‹ã—ã€**`b.Loop` ã¯ã“ã®æŒ™å‹•ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ï¼**

`go doc testing.B.Loop` ã®çµæœã‚’ä¸€éƒ¨æŠœç²‹ã—ã¦ã¿ã¾ã—ãŸã€‚

```bash
â¯ go doc testing.B.Loop
package testing // import "testing"

func (b *B) Loop() bool
    Loop returns true as long as the benchmark should continue running.

    A typical benchmark is structured like:

        func Benchmark(b *testing.B) {
                ... setup ...
                for b.Loop() {
                        ... code to measure ...
                }
                ... cleanup ...
        }

    Loop resets the benchmark timer the first time it is called in a benchmark,
    so any setup performed prior to starting the benchmark loop does not count
    toward the benchmark measurement. Likewise, when it returns false, it stops
    the timer so cleanup code is not measured.

	// çœç•¥
```

`Loop resets the benchmark timer ...` ã¨ã‚ã‚‹ã‚ˆã†ã«ã€ãƒ«ãƒ¼ãƒ—ã®åˆã‚ã¨çµ‚ã‚ã‚Šã«ã‚¿ã‚¤ãƒã®ãƒªã‚»ãƒƒãƒˆã¨ã‚¹ãƒˆãƒƒãƒ—ãŒè¡Œã‚ã‚Œã¦ã„ã¾ã™ï¼

# `b.Loop` ãƒãƒ³ã‚¶ã‚¤ ğŸ™Œ ã¨æ€ã‚ã‚ŒãŸãŒ...ï¼Ÿ

ã€Œ`b.Loop` æœ€é«˜ï¼ã€ã¨è¨€ã„ãŸã„ã¨ã“ã‚ã§ã™ï¼ï¼(å°‘ãªãã¨ã‚‚ç­†è€…ã¯ç¾æ™‚ç‚¹ã§ã® `b.Loop` ã®å®Ÿè£…ã«ä½•ã®ä¸æº€ã‚‚ã‚ã‚Šã¾ã›ã‚“ w)

ã—ã‹ã—ã€2025/04/08 æ™‚ç‚¹ã§ [testing: implement b.Loop keepalive without preventing inlining, which can lead to heap allocs](https://github.com/golang/go/issues/73137) ã¨ã„ã† issue ãŒç«‹ã¦ã‚‰ã‚Œã¦ã„ã¾ã—ãŸã€‚

ã–ã£ãã‚Šã¨ issue ã®å†…å®¹ã‚’ã¾ã¨ã‚ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

1. `b.Loop` ã‚’ä½¿ç”¨ã—ã¦ã—ã¾ã†ã¨ã€å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ã§ä½¿ç”¨ã•ã‚Œã‚‹ã‚ˆã†ãªå‘¼ã³å‡ºã—ã¨ã¯ç•°ãªã‚‹å‘¼ã³å‡ºã—ãŒè¡Œã‚ã‚Œã‚‹ã‚±ãƒ¼ã‚¹ãŒã‚ã‚‹
1. ä¸Šè¨˜ã®ã‚ˆã†ãªæ¬ ç‚¹ãŒã‚ã‚‹ã®ã§ãã‚Œã‚‰ã«ã¤ã„ã¦ã©ã“ã‹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§è¨€åŠã—ãŸæ–¹ãŒè‰¯ã„ã®ã§ã¯ãªã„ã‹
1. API docs ã«ã€å°†æ¥çš„ã«å¤‰æ›´ãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’è¨˜è¼‰ã—ãŸæ–¹ãŒè‰¯ã„ã®ã§ã¯ãªã„ã‹

ã¨ã„ã†ã“ã¨ã§ã—ãŸã€‚

---

issue ã®å†…å®¹ã‚’è©³ã—ãè¦‹ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ ğŸ‘€

ä¸‹è¨˜ã®ã‚ˆã†ãªé–¢æ•°ã®ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’è¨ˆæ¸¬ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã¾ã™ã€‚

```go
func NewX(x int) []byte {
	out := make([]byte, 8)
	return newX(out, x)
}

//go:noinline
func newX(out []byte, x int) []byte {
	binary.LittleEndian.PutUint64(out, uint64(x))
	return out
}
```

å¾“æ¥ã® sink-based ãª `b.N` ã‚’ç”¨ã„ãŸãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```go
	b.Run("b.N", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			out := NewX(42)
			sink = out[0]
		}
	})
```

ã“ã®ã‚ˆã†ãªãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã§ã¯ã€ãƒ’ãƒ¼ãƒ—é ˜åŸŸã¸ã®ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¿ã‘ã‚‹ã“ã¨ã«ãªã‚Šã€ãã‚Œã¯å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰å‘¼ã³å‡ºã—ã¨åŒã˜ã‚ˆã†ãªçŠ¶æ³ã¨ãªã‚Šã¾ã™ã€‚

ã¤ã¾ã‚Šã€**å®Ÿéš›ã«ã‚³ãƒ¼ãƒ‰ãŒå‹•ãç’°å¢ƒã«è¿‘ã„ç’°å¢ƒã§ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãŒå–ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã§ã™ï¼**

# ã¾ã¨ã‚ã‚‹ã¨

# å‚ç…§

- [Common pitfalls in Go benchmarking](https://eli.thegreenplace.net/2023/common-pitfalls-in-go-benchmarking/)
- [How to write benchmarks in Go](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)
- [Efficient Go APIs with the mid-stack inliner](https://words.filippo.io/efficient-go-apis-with-the-inliner/)
